# ブラウザのメモリとストレージ まとめ

## 1. 物理的な保存場所

### メモリ(NgRxストアなど)
```
場所: RAM(メモリチップ)
実体: 電気信号
形式: ファイルではない
特性: 電源を切ると消える
```

### ストレージ(localStorage)
```
場所: ディスク(SSD/HDD)
実体: ファイル
パス: ~/.config/google-chrome/Default/Local Storage/https_example.com_0.localstorage
特性: 電源を切っても残る
```

---

## 2. 管理単位

### メモリの管理単位: **プロセス**

```
ブラウザアプリケーション
├── Browser Process(メインプロセス)
├── Renderer Process #1234 (サイトA)
│   └── RAM領域: 0x1000000〜0x2000000
│       └── NgRxストア: { user: 'Alice' }
├── Renderer Process #5678 (サイトB)
│   └── RAM領域: 0x3000000〜0x4000000
│       └── NgRxストア: { user: 'Bob' }
└── GPU Process
```

### ストレージの管理単位: **Origin**

```
Origin = スキーム + ホスト + ポート

例:
https://example.com       → Origin A
https://example.com:8080  → Origin B (別)
https://sub.example.com   → Origin C (別)
```

---

## 3. なぜリロードで消えるのか?

```
リロード前:
プロセス#1234
└── RAM領域にNgRxストア保存

↓ F5キー

1. ブラウザがプロセス#1234を終了(kill)
2. OSがRAM領域を回収 ← データ消失!
3. 新しいプロセス#9999を起動
4. 新しいRAM領域を割り当て(空)

リロード後:
プロセス#9999
└── RAM領域は空っぽ
```

**比喩:** アパート退去 → 荷物は捨てられる

---

## 4. なぜタブ間でメモリ共有できないのか?

```
タブA(プロセス#1234) → RAM領域A
タブB(プロセス#5678) → RAM領域B

プロセス#5678は、RAM領域Aにアクセスできない
理由: OSがセキュリティのため禁止
```

**別プロセス = 別のメモリ領域 = アクセス不可**

**比喩:** 別の部屋の冷蔵庫は開けられない

---

## 5. タブ切り替えとリロードの違い

| 操作 | プロセス | メモリ | NgRxストア |
|------|---------|--------|-----------|
| **タブ切り替え** | 一時停止(生きてる) | 保持 | 残る ✓ |
| **リロード(F5)** | 終了 → 新規作成 | 回収 | 消える × |
| **別タブで開く** | 別プロセス | 別領域 | アクセス不可 × |

---

## 6. 使い分けの判断基準

### NgRxストア(メモリ)を使うケース

- ✅ 同じタブ内のページ遷移で状態を保持
- ✅ リアルタイムな状態管理
- ✅ Redux DevToolsで追跡したい

```typescript
// Angular SPA内のルーティング
ページA → ページB (同じプロセス)
→ NgRxストアは残る
```

### localStorageを使うケース

- ✅ リロード後も状態を復元したい
- ✅ 別タブにデータを渡したい
- ✅ 永続化が必要

```typescript
// 別タブに情報を渡す
タブA → window.open() → タブB (別プロセス)
→ メモリ共有不可
→ localStorageが必要
```

---

## 7. 実装パターン

### パターン1: 同一タブ内のページ遷移

```typescript
// NgRxだけで十分
this.searchForm.get('keyword')!.valueChanges.pipe(
  debounceTime(300),
  distinctUntilChanged()
).subscribe(keyword => {
  this.store.dispatch(setSearchKeyword({ keyword }));
});

// ページ遷移後
this.store.select(selectKeyword).subscribe(keyword => {
  this.searchForm.patchValue({ keyword });
});
```

### パターン2: 別タブへのデータ受け渡し

```typescript
// タブA: 別タブを開く前にlocalStorageに保存
localStorage.setItem('data', JSON.stringify(data));
window.open('/new-page', '_blank');

// タブB: localStorageから読み込み
const data = JSON.parse(localStorage.getItem('data'));
```

### パターン3: リロード後も復元

```typescript
// NgRx + localStorage の併用
// 保存: ストア変更時にlocalStorageに同期
this.store.select(selectState).pipe(
  debounceTime(500)
).subscribe(state => {
  localStorage.setItem('state', JSON.stringify(state));
});

// 復元: アプリ起動時にlocalStorageから読み込み
const savedState = JSON.parse(localStorage.getItem('state'));
if (savedState) {
  this.store.dispatch(restoreState({ state: savedState }));
}
```

---

## 8. パフォーマンス比較

| 項目 | メモリ(NgRx) | localStorage |
|------|-------------|--------------|
| **速度** | ナノ秒オーダー | マイクロ秒オーダー(1000倍遅い) |
| **型安全性** | TypeScript型そのまま | string型のみ |
| **容量** | プロセスのメモリ次第 | 5-10MB制限 |
| **永続性** | プロセス終了で消失 | 削除するまで残る |
| **デバッグ** | Redux DevTools | Application タブで確認 |

---

## 9. よくある誤解

### ❌ 誤解1: 「タブ切り替えでNgRxが消える」
→ **消えない**。プロセスは生きているので残る。

### ❌ 誤解2: 「別タブでもNgRxにアクセスできる」
→ **できない**。別プロセスなのでメモリ領域が違う。

### ❌ 誤解3: 「localStorage使えば全部解決」
→ **遅い**。同一タブ内ならNgRxの方が高速。

---

## 10. チェックリスト

あなたのケースでlocalStorageが必要か判断:

```
□ リロード後も状態を保持したい?
  → YES: localStorage検討
  → NO: NgRxで十分

□ 別タブにデータを渡したい?
  → YES: localStorage必須
  → NO: NgRxで十分

□ 同一タブ内のページ遷移だけ?
  → YES: NgRxで十分
  → NO: 要件を再確認
```

---

## まとめ

```
メモリ(NgRx)
- 場所: RAMチップ
- 単位: プロセス
- 速い、揮発性
- 同一プロセス内で共有

ストレージ(localStorage)
- 場所: ディスクのファイル
- 単位: Origin
- 遅い、永続性
- すべてのプロセスから読める

使い分け:
同一タブ → メモリ
別タブ・永続化 → ストレージ
```


良い質問ですね!公式仕様を確認しましょう。はい、公式仕様とドキュメントがあります!整理してお伝えします。

## ブラウザのストレージとメモリに関する公式仕様・ドキュメント

### 1. **ストレージ(localStorage/sessionStorage)の仕様**

#### WHATWG HTML Living Standard(最新仕様)
WHATWGのHTML仕様でWeb Storage APIが定義されており、localStorageとsessionStorageの両方がOriginごとに分離され、各Originは独自の分離されたストレージ領域を持ちます。

**公式仕様:**
- **WHATWG HTML Standard - Web Storage**: https://html.spec.whatwg.org/multipage/webstorage.html
- **Web Storage API (MDN)**: https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API

**重要な定義:**
sessionStorageは、Originとブラウザタブ(トップレベルブラウジングコンテキスト)の両方によって分割されます。sessionStorageのデータはページセッションの期間中のみ保持され、タブ/ウィンドウを閉じるとセッションが終了しデータがクリアされます。

localStorageはOriginのみによって分割されます。同じOriginを持つすべてのドキュメントは同じlocalStorage領域にアクセスでき、ブラウザを閉じて再度開いた後でも永続化されます。

---

### 2. **Origin(オリジン)の定義**

#### RFC 6454 - The Web Origin Concept
2つのURLが同じOriginを持つのは、プロトコル、ポート、ホストがすべて同じである場合です。これは「スキーム/ホスト/ポート・タプル」として参照されます。

**公式仕様:**
- **RFC 6454**: https://tools.ietf.org/html/rfc6454
- **Same-origin policy (MDN)**: https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy

**Originの例:**
```
http://example.com/page.html

Origin = http(スキーム) + example.com(ホスト) + 80(ポート)
```

---

### 3. **プロセス分離とSite Isolation**

#### Chromium公式ドキュメント

**主要なドキュメント:**
- **Process Models**: https://chromium.googlesource.com/chromium/src/+/main/docs/process_model_and_site_isolation.md
- **Site Isolation**: https://www.chromium.org/Home/chromium-security/site-isolation/
- **Site Isolation Design Document**: https://www.chromium.org/developers/design-documents/site-isolation/

先ほど調べた内容の元ソースです。

---

### 4. **ブラウジングコンテキストとプロセス**

#### WHATWG HTML Standard - Browsing contexts

**公式仕様:**
- **HTML Standard - Browsers**: https://html.spec.whatwg.org/multipage/browsers.html

ドキュメントのエージェントクラスターのクロスオリジン分離モードが"none"でないドキュメントは、自動的にOriginごとにキー付けされます。

---

### 5. **メモリ管理(JavaScriptエンジン)**

#### ECMAScript仕様(間接的)

JavaScriptのメモリ管理は、ECMAScript仕様では直接定義されていませんが、V8(Chrome)やSpiderMonkey(Firefox)などのエンジンが実装します。

**公式ドキュメント:**
- **V8 Documentation**: https://v8.dev/docs
- **ECMAScript Specification**: https://tc39.es/ecma262/

**ただし:**
- メモリの「どこに保存されるか」はブラウザの実装詳細
- 仕様では「プロセス」「RAM」などは定義されていない
- 各ブラウザベンダーの設計ドキュメントを参照する必要がある

---

### 6. **ブラウザアーキテクチャ(実装レベル)**

#### Chrome公式ブログ
- **Inside look at modern web browser**: https://developer.chrome.com/blog/inside-browser-part1

#### Firefox公式ドキュメント
- **Process Isolation in Firefox**: https://mozilla.github.io/firefox-browser-architecture/text/0012-process-isolation-in-firefox.html

---

## 仕様の階層構造

```
┌─────────────────────────────────────┐
│ Web標準仕様(W3C/WHATWG)              │
│ - localStorage/sessionStorage        │
│ - Same-Origin Policy                 │
│ - Browsing Context                   │
└─────────────────────────────────────┘
          ↓ 実装
┌─────────────────────────────────────┐
│ ブラウザベンダーの設計ドキュメント      │
│ - Chromium: Site Isolation           │
│ - Firefox: Electrolysis/Fission      │
│ - プロセスモデル                      │
└─────────────────────────────────────┘
          ↓ 実装
┌─────────────────────────────────────┐
│ 実装詳細(ソースコード)                │
│ - V8エンジン                         │
│ - メモリアロケーション                │
│ - OSプロセス管理                     │
└─────────────────────────────────────┘
```

---

## まとめ: どの仕様を読むべきか

### ストレージの仕様を知りたい
→ **WHATWG HTML Standard (Web Storage)**
https://html.spec.whatwg.org/multipage/webstorage.html

### Originの定義を知りたい
→ **RFC 6454 + MDN Same-origin policy**
https://tools.ietf.org/html/rfc6454

### プロセス分離を知りたい
→ **Chromium Process Models & Site Isolation**
https://chromium.googlesource.com/chromium/src/+/main/docs/process_model_and_site_isolation.md

### メモリ管理の詳細を知りたい
→ **ブラウザ固有の実装ドキュメント**
- Chrome: V8 Documentation
- Firefox: SpiderMonkey Documentation

---

**重要な注意点:**

Web Storageやブラウザのメモリに保存されたデータへのアクセスはOriginによって分離されます。各OriginはそれぞれのストレージとJavaScriptオブジェクトを持ち、あるOriginのJavaScriptは別のOriginに属するストレージから読み取ったり書き込んだりすることはできません。

これが、あなたが体験した「別タブでメモリにアクセスできない」理由の仕様的根拠です。

参考になりましたか?
